Definitions While many programming languages obscure the relationship between
programs and functions, BSL brings it to the fore. Every BSL program consists of
 several definitions, usually followed by an expression that involves those
 definitions. There are two kinds of definitions:

constant definitions, of the shape (define Variable Expression), which we
encountered in the preceding chapter; and

function definitions, which come in many flavors, one of which we used in the
Prologue.

Like expressions, function definitions in BSL come in a uniform shape:
(define (FunctionName Variable ... Variable)
  Expression)


Exercise 11:
Define a function that consumes two numbers, x and y, and that computes the
distance of point (x,y) to the origin.

(define (distance x y)
    (sqrt (+ (sqr x) (sqr y))))


Exercise 12. Define the function cvolume, which accepts the length of a side of
an equilateral cube and computes its volume. If you have time, consider
defining csurface, too.

(define (cvolume side)
    (* side (sqr side)))


Exercise 13. Define the function string-first, which extracts the first 1String
from a non-empty string.

(define (string-first str)
    (if (string? str)
    (substring str 0 1) "not a string"))


Exercise 14. Define the function string-last, which extracts the last 1String
from a non-empty string.

(define (string-last str)
    (if (string? str)
    (substring str (- (string-length str) 1) (string-length str)) "not a string"))


Exercise 15. Define ==>. The function consumes two Boolean values, call them
sunny and friday. Its answer is #true if sunny is false or friday is true.
Note Logicians call this Boolean operation implication, and they use the
notation sunny => friday for this purpose.

(define (==> sunny friday)
    (if (false? sunny) #true
        (if (false? friday) #false #true)))


Exercise 16. Define the function image-area, which counts the number of pixels
in a given image.

(define (image-area image-height image-width)
    (* image-height image-width))

(define (image-area image)
    (* (image-height image) (image-width image)))


Exercise 17. Define the function image-classify, which consumes an image and
conditionally produces "tall" if the image is taller than wide, "wide" if it
is wider than tall, or "square" if its width and height are the same.

(define (image-classify image)
    (if (= (image-height image ) (image-width image)) "square"
        (if (> (image-height image ) (image-width image)) "tall" "wide")))


Exercise 18. Define the function string-join, which consumes two strings and
appends them with "_" in between.

(define (string-join string1 string2)
    (string-append string1 "_" string2))


Exercise 19. Define the function string-insert, which consumes a string str
plus a number i and inserts "_" at the ith position of str. Assume i is a
number between 0 and the length of the given string (inclusive). See exercise
3 for ideas. Ponder how string-insert copes with "".

(define (string-insert str i)
    (string-append (substring str 0 i) "_" (substring str i (string-length str))))


Exercise 20. Define the function string-delete, which consumes a string plus a
number i and deletes the ith position from str. Assume i is a number between
0 (inclusive) and the length of the given string (exclusive).

(define (string-delete str i)
    (string-append (substring str 0 (- i 1)) (substring str (+ i 1) (string-length str))))


2.2 Computing



Exercise 21. Use DrRacket’s stepper to evaluate (ff (ff 1)) step-by-step.
Also try (+ (ff 1) (ff 1)). Does DrRacket’s stepper reuse the results of
computations?

No.



Exercise 22. Use DrRacket’s stepper on this program fragment:

(define (distance-to-origin x y)
  (sqrt (+ (sqr x) (sqr y))))
(distance-to-origin 3 4)

Does the explanation match your intuition?

Yes.


Exercise 23. The first 1String in "hello world" is "h". How does the following
function compute this result?

(define (string-first s)
  (substring s 0 1))

Use the stepper to confirm your ideas.

(define (string-first s)
  (substring s 0 1))
(string-first "hello world")

(string-first "hello world")    (substring "hello world" 0 1)
(substring "hello world" 0 1)   "h"


Exercise 24. Here is the definition of ==>: y
(define (==> x y)
  (or (not x) y))
Use the stepper to determine the value of (==> #true #false)

(define (==> x y)
  (or (not x) y))
(==> #true #false)

(==> #true #false)          (or (not #true) #false)
(or (not #true) #false)     (or #false #false)
(or #false #false)          #false


Exercise 25. Take a look at this attempt to solve exercise 17:
(define (image-classify img)
  (cond
    [(>= (image-height img) (image-width img)) "tall"]
    [(= (image-height img) (image-width img)) "square"]
    [(<= (image-height img) (image-width img)) "wide"]))
Does stepping through an application suggest a fix?

Only with a known square image.


Exercise 26. What do you expect as the value of this program:
(define (string-insert s i)
  (string-append (substring s 0 i)
                 "_"
                 (substring s i)))

(string-insert "helloworld" 6)
Confirm your expectation with DrRacket and its stepper.

"hellow_orld"

confirmed


2.3 Composing Functions

A program rarely consists of a single function definition. Typically, programs
consist of a main definition and several other functions and turns the result
of one function application into the input for another. In analogy to algebra,
we call this way of defining functions composition, and we call these
additional functions auxiliary functions or helper functions.


(define (attendees ticket-price)
  (- 120 (* (- ticket-price 5.0) (/ 15 0.1))))

(define (revenue ticket-price)
  (* ticket-price (attendees ticket-price)))

(define (cost ticket-price)
  (+ 180 (* 0.04 (attendees ticket-price))))

(define (profit ticket-price)
  (- (revenue ticket-price)
     (cost ticket-price)))

Exercise 27. Our solution to the sample problem contains several constants
in the middle of functions. As One Program, Many Definitions already points
out, it is best to give names to such constants so that future readers
understand where these numbers come from. Collect all definitions in DrRacket’s
definitions area and change them so that all magic numbers are refactored
into constant definitions.

(define default-price 5.0)
(define default-attendance 120)
(define fixed-cost 180)
(define average-attendance-change 15)
(define default-price-delta 0.1)
(define variable-cost 0.04)

(define (attendees ticket-price)
  (- default-attendance (* (- ticket-price default-price) (/ average-attendance-change default-price-delta))))

(define (revenue ticket-price)
  (* ticket-price (attendees ticket-price)))

(define (cost ticket-price)
  (+ fixed-cost (* variable-cost (attendees ticket-price))))

(define (profit ticket-price)
  (- (revenue ticket-price)
     (cost ticket-price)))

Exercise 28. Determine the potential profit for these ticket prices: $1, $2,
$3, $4, and $5. Which price maximizes the profit of the movie theater?
Determine the best ticket price to a dime.

> (profit 1)
511.2
> (profit 2)
937.2
> (profit 3)
1063.2
> (profit 4)
889.2
> (profit 5)
415.2

(require dyoo-while-loop)

(define default-price 5.0)
(define default-attendance 120)
(define fixed-cost 180)
(define average-attendance-change 15)
(define default-price-delta 0.1)
(define variable-cost 0.04)

(define (attendees ticket-price)
  (- default-attendance (* (- ticket-price default-price) (/ average-attendance-change default-price-delta))))

(define (revenue ticket-price)
  (* ticket-price (attendees ticket-price)))

(define (cost ticket-price)
  (+ fixed-cost (* variable-cost (attendees ticket-price))))

(define (profit ticket-price)
  (- (revenue ticket-price)
     (cost ticket-price)))

(define (loop ticket-start ticket-end)
  (while (<= ticket-start ticket-end) (profit ticket-start) (+ ticket-start 0.1)))

This should work, it doesn't because no while, but it should


Exercise 29. After studying the costs of a show, the owner discovered several
ways of lowering the cost. As a result of these improvements, there is no
longer a fixed cost; a variable cost of $1.50 per attendee remains.

(define default-price 5.0)
(define default-attendance 120)
(define average-attendance-change 15)
(define default-price-delta 0.1)
(define variable-cost 1.5)

(define (attendees ticket-price)
  (- default-attendance (* (- ticket-price default-price) (/ average-attendance-change default-price-delta))))

(define (revenue ticket-price)
  (* ticket-price (attendees ticket-price)))

(define (cost ticket-price)
  (* variable-cost (attendees ticket-price)))

(define (profit ticket-price)
  (- (revenue ticket-price)
     (cost ticket-price)))

 > (profit 1)
 -360
 > (profit 2)
 285
 > (profit 3)
 630
 > (profit 4)
 675
 > (profit 5)
 420
 >


2.4 Global Constants

For every constant mentioned in a problem statement, introduce one
constant definition.

Exercise 30. Define constants for the price optimization program at the movie
theater so that the price sensitivity of attendance (15 people for every 10
cents) becomes a computed constant.

(define default-price 5.0)
(define default-attendance 120)
(define average-attendance-change 15)
(define default-price-delta 0.1)
(define variable-cost 1.5)
(define price-sensitivity (/ average-attendance-change default-price-delta))
(define price-sensitivity2 (/ 15 0.1))

(define (attendees ticket-price)
  (- default-attendance (* (- ticket-price default-price) (price-sensitivty))))

(define (revenue ticket-price)
  (* ticket-price (attendees ticket-price)))

(define (cost ticket-price)
  (* variable-cost (attendees ticket-price)))

(define (profit ticket-price)
  (- (revenue ticket-price)
     (cost ticket-price)))


2.5 Programs

You are ready to create simple programs. From a coding perspective, a program
is just a bunch of function and constant definitions. Usually one function is
singled out as the “main” function, and this main function tends to compose
others. From the perspective of launching a program, however, there are two
distinct kinds:

    a batch program consumes all of its inputs at once and computes its result.
    Its main function is the composition of auxiliary functions, which may
    refer to additional auxiliary functions, and so on. When we launch a
    batch program, the operating system calls the main function on its inputs
    and waits for the program’s output.

    an interactive program consumes some of its inputs, computes, produces
    some output, consumes more input, and so on. When an input shows up, we
    speak of an event, and we create interactive programs as event-driven
    programs. The main function of such an event-driven program uses an
    expression to describe which functions to call for which kinds of events.
    These functions are called event handlers.

When we launch an interactive program, the main function informs the operating
system of this description. As soon as input events happen, the operating
system calls the matching event handler. Similarly, the operating system knows
from the description when and how to present the results of these function
calls as output.

Programs are even more useful if they can retrieve the input from some file
and deliver the output to some other file. Indeed, the name “batch program”
dates to the early days of computing when a program read a file (or several
files) from a batch of punch cards and placed the result in some other file(s),
also a batch of cards. Conceptually, a batch program reads the input file(s)
at once and also produces the result file(s) all at once.


Exercise 31.
Here is a letter-writing batch program that reads names from three files and
writes a letter to one:
(define (main in-fst in-lst in-signature out)
  (write-file out
              (letter (read-file in-fst)
                      (read-file in-lst)
                      (read-file in-signature))))
The function consumes four strings: the first three are the names of input
files and the last one serves as an output file. It uses the first three to
read one string each from the three named files, hands these strings to letter,
and eventually writes the result of this function call into the file named by
out, the fourth argument to main.

Create appropriate files, launch main, and check whether it delivers the
expected letter in a given file.

(write-file "first.dat" "James")
(write-file "last.dat" "Mitchell")
(write-file "sig.dat" "Lottery Commission")

> (main "first.dat" "last.dat" "sig.dat" "output.dat")
"output.dat"
> (read-file "output.dat")
"Dear James,\n\nWe have discovered that all people with the\nlast name Mitchell
have won our lottery. So, \nJames, hurry and pick up your prize.\n\nSincerely,
\n\nLottery Commission"
